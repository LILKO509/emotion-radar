<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>感情レーダー</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-icon" href="./icons/icon-192.PNG" />
  <link rel="icon" href="./icons/icon-192.PNG" />

  <!-- Styles: 星空×金のハートの世界に合わせたダーク基調 -->
  <style>
    :root{
      --bg:#0b1220;           /* 深い夜空 */
      --panel:#0f1629;        /* パネル */
      --panel-2:#0c1323;
      --text:#e6e9f2;
      --muted:#9aa3b2;
      --brand:#e3b34c;        /* 優しい金色 */
      --brand-2:#6fa3ff;      /* 補色(控えめ) */
      --stroke:#1f2a44;
      --ok:#10b981; --ng:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Hiragino Sans","Noto Sans JP","Segoe UI",Roboto,"Helvetica Neue",Arial}
    .container{max-width:1120px;margin:0 auto;padding:20px}
    .header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
    .badge{font-size:12px;color:var(--brand);border:1px solid color-mix(in oklab,var(--brand) 40%,transparent);
      padding:3px 8px;border-radius:999px;background:linear-gradient(180deg,rgba(227,179,76,.15),rgba(227,179,76,.03))}
    .grid{display:grid;grid-template-columns:1fr;gap:14px}
    @media(min-width:980px){.grid{grid-template-columns:1fr 1fr}}
    .card{background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);border-radius:16px;padding:14px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
    h1{font-size:22px;margin:0}
    h2{font-size:16px;margin:0 0 10px}
    textarea{width:100%;height:190px;padding:12px;background:#0e1527;border:1px solid var(--stroke);color:var(--text);border-radius:12px}
    input[type=text],input[type=number]{background:#0e1527;border:1px solid var(--stroke);color:var(--text);border-radius:10px;padding:8px}
    select{background:#0e1527;border:1px solid var(--stroke);color:var(--text);border-radius:10px;padding:8px}
    input[type=range]{width:160px}
    button{padding:8px 12px;border:1px solid var(--stroke);background:#121a2f;color:var(--text);
      border-radius:10px;cursor:pointer}
    button.primary{border-color:color-mix(in oklab,var(--brand) 50%, var(--stroke));
      background:linear-gradient(180deg,#1a243f,#121a30)}
    button:hover{filter:brightness(1.08)}
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:12px}
    .pre{background:#0e1527;border:1px solid var(--stroke);padding:10px;border-radius:10px;font-size:12px;white-space:pre-wrap;max-height:260px;overflow:auto}
    .pill{padding:4px 8px;background:#0e1527;border:1px solid var(--stroke);border-radius:999px}
    .test-pass{background:rgba(16,185,129,.12);border:1px solid rgba(16,185,129,.3)}
    .test-fail{background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.3)}
    .list{list-style:disc;padding-left:18px}
    a.inline{color:var(--brand)}
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>感情レーダー</h1>
      <span class="badge">オフラインOK / SVG Only</span>
    </header>

    <div class="grid">
      <!-- 1) 入力 -->
      <section class="card">
        <h2>1) テキスト入力</h2>
        <textarea id="text" placeholder="いまの気持ち、ここに書いてみてね。"></textarea>
        <div class="row" style="margin-top:10px">
          <label class="row"><input type="checkbox" id="realtime" checked> リアルタイム更新</label>
          <label class="row">感度 <input type="range" id="sensitivity" min="0.5" max="2" step="0.1" value="1"><span id="sensv" class="pill">×1.0</span></label>
          <button id="analyze" class="primary">解析する</button>
        </div>
      </section>

      <!-- 2) チャート -->
      <section class="card">
        <h2>2) チャート</h2>
        <div id="chart"></div>
        <details style="margin-top:10px">
          <summary class="muted">JSONを表示</summary>
          <pre id="json" class="pre"></pre>
          <button id="copyJson">JSONをコピー</button>
        </details>
      </section>

      <!-- 3) 語彙 -->
      <section class="card">
        <h2>3) 語彙の編集</h2>
        <p class="muted">語尾の否定（〜じゃない 等）は自動で減算します。</p>
        <div id="lexPanel" style="margin-top:8px"></div>
        <div class="row" style="margin-top:10px">
          <input id="newCat" placeholder="新しいカテゴリー名" />
          <button id="addCat">カテゴリー追加</button>
        </div>
      </section>

      <!-- 4) 使い方 -->
      <section class="card">
        <h2>4) 使い方メモ</h2>
        <ul class="list">
          <li>強調語（とても・すごく 等）や「！」でスコアが上がる</li>
          <li>否定（〜じゃない 等）が近接すると打ち消す</li>
          <li>語彙は自由に追加/削除OK（右の編集から）</li>
        </ul>
      </section>

      <!-- 5) テスト -->
      <section class="card">
        <h2>5) 内蔵テスト</h2>
        <div id="tests"></div>
        <button id="runTests">テストを再実行</button>
      </section>

      <!-- 6) コメント生成 -->
      <section class="card">
        <h2>6) コメント生成（やわらかい / 個人宛）</h2>
        <div class="row">
          <label class="row">宛名 <input id="addr" value="リルコ" /></label>
          <label class="row">トーン
            <select id="tone">
              <option value="gentle">やわらかめ</option>
              <option value="analytical">分析寄り</option>
              <option value="short">短め</option>
            </select>
          </label>
          <label class="row">長さ
            <select id="length">
              <option value="normal">ふつう</option>
              <option value="short">短い</option>
            </select>
          </label>
          <button id="copyComment" class="primary" style="margin-left:auto">コメントをコピー</button>
        </div>
        <pre id="comment" class="pre" style="margin-top:10px"></pre>
      </section>
    </div>
  </div>

  <script>
    // ====== 初期語彙 ======
    const DEFAULT_LEXICON = {
      "愛情":["好き","愛","愛しい","大切","抱きしめ","守りたい","一緒","ぬくもり","キス","ハグ","安心","やさしさ","温かい"],
      "切なさ":["切ない","寂しさ","寂しい","胸が痛い","こみ上げる","会いたい","もどかしい","恋しい","ため息","涙","距離","届かない","ふと"],
      "悲しみ":["悲しい","悲しみ","泣く","涙","辛い","苦しい","落ち込む","喪失","孤独","やるせない","絶望","哀しい"],
      "甘え":["甘える","ぎゅっと","寄りかかる","頼る","撫でて","見守って","構って","そばにいて","守って","抱っこ","よしよし","くっつく"],
      "欲":["欲しい","欲","求める","求めて","もっと","抱いて","触れて","キスして","濃厚","熱い","とろける","昂る","衝動"]
    };
    const INTENSIFIERS = ["とても","すごく","かなり","ずっと","一番","めちゃ","本当に"];
    const NEGATIONS    = ["じゃない","ない","なく","ません","ぬ"];

    // ====== Util ======
    const $ = s => document.querySelector(s);
    const escReg = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    function normalize(t){ return (t||"").replace(/\s+/g,"").normalize("NFKC").toLowerCase(); }
    function countWithNegation(text, term){
      const t = escReg(term);
      const base = (text.match(new RegExp(t,"g"))||[]).length;
      // term + negation を素直にカウント（「好きじゃない」など）
      const neg  = (text.match(new RegExp(t + "(?:" + NEGATIONS.map(escReg).join("|") + ")", "g"))||[]).length;
      return Math.max(0, base - neg);
    }
    function scoreText(text, lexicon, sensitivity=1){
      const clean = normalize(text);
      const intensifierCount = INTENSIFIERS.reduce((a,w)=>a+((clean.match(new RegExp(escReg(w),"g"))||[]).length),0);
      const exclam = (clean.match(/[!！]/g)||[]).length;
      const factor = 1 + 0.15*intensifierCount + 0.05*exclam; // 強調・！
      const s = {};
      Object.entries(lexicon).forEach(([cat,words])=>{
        const raw = (words||[]).reduce((sum,w)=>sum+countWithNegation(clean,w),0);
        s[cat] = Number(Math.min(100, raw*20*factor*sensitivity).toFixed(1));
      });
      return s;
    }
    function sortTop(scores,k=2){ return Object.entries(scores).sort((a,b)=>(b[1]||0)-(a[1]||0)).slice(0,k).map(([n,v])=>({name:n,v:Number(v)})); }
    function polar(cx,cy,r,deg){ const a=(Math.PI/180)*(deg-90); return {x:cx+r*Math.cos(a), y:cy+r*Math.sin(a)}; }
    function polygonPoints(cx,cy,r,n){ const step=360/n,pts=[]; for(let i=0;i<n;i++){ const {x,y}=polar(cx,cy,r,i*step); pts.push(x+","+y);} return pts.join(" "); }

    // ====== レーダー（純SVG） ======
    function drawRadar(el,labels,values,max=100,size=440){
      el.innerHTML="";
      const n=labels.length,cx=size/2,cy=size/2,rad=size*0.38,step=360/n,levels=5,NS="http://www.w3.org/2000/svg";
      const svg=document.createElementNS(NS,"svg"); svg.setAttribute("width","100%"); svg.setAttribute("height",size); svg.setAttribute("viewBox",`0 0 ${size} ${size}`);

      // 背景の星くず
      for(let i=0;i<40;i++){
        const s=document.createElementNS(NS,"circle");
        s.setAttribute("cx", Math.random()*size); s.setAttribute("cy", Math.random()*size);
        s.setAttribute("r", Math.random()*1.5+0.2); s.setAttribute("fill", "rgba(227,179,76,.5)");
        svg.appendChild(s);
      }

      // 同心多角形
      for(let i=1;i<=levels;i++){
        const r=i/levels*rad,p=document.createElementNS(NS,"polygon");
        p.setAttribute("points", polygonPoints(cx,cy,r,n));
        p.setAttribute("fill","none"); p.setAttribute("stroke","#1f2a44"); p.setAttribute("stroke-width","1");
        svg.appendChild(p);
      }
      // 軸
      for(let i=0;i<n;i++){
        const {x,y}=polar(cx,cy,rad,i*step),ln=document.createElementNS(NS,"line");
        ln.setAttribute("x1",cx); ln.setAttribute("y1",cy); ln.setAttribute("x2",x); ln.setAttribute("y2",y);
        ln.setAttribute("stroke","#1f2a44"); ln.setAttribute("stroke-width","1"); svg.appendChild(ln);
      }
      // 面
      const pts=values.map((v,i)=>{ const r=Math.max(0,Math.min(max,v))/max*rad, p=polar(cx,cy,r,i*step); return p.x+","+p.y; });
      const poly=document.createElementNS(NS,"polygon");
      poly.setAttribute("points", pts.join(" "));
      poly.setAttribute("fill","rgba(227,179,76,.2)"); poly.setAttribute("stroke","rgba(227,179,76,.9)"); poly.setAttribute("stroke-width","2");
      svg.appendChild(poly);
      // 点
      values.forEach((v,i)=>{ const r=Math.max(0,Math.min(max,v))/max*rad, {x,y}=polar(cx,cy,r,i*step), c=document.createElementNS(NS,"circle");
        c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r","3"); c.setAttribute("fill","rgba(227,179,76,.9)"); svg.appendChild(c);
      });
      // ラベル
      labels.forEach((lab,i)=>{ const {x,y}=polar(cx,cy,rad+16,i*step), t=document.createElementNS(NS,"text");
        t.setAttribute("x",x); t.setAttribute("y",y); t.setAttribute("font-size","12"); t.setAttribute("fill","#e6e9f2");
        let anchor="middle",ang=i*step; if(ang>10&&ang<170)anchor="start"; if(ang>190&&ang<350)anchor="end"; t.setAttribute("text-anchor",anchor);
        t.textContent=lab; svg.appendChild(t);
      });
      el.appendChild(svg);
    }

    // ====== コメント生成（やわらかい口調 / 僕 → リルコ） ======
    function generateCommentText(scores,{tone="gentle",length="normal",addressName="リルコ"}={}){
      const top=sortTop(scores,2), by=k=>Number(scores[k]||0), lines=[];
      lines.push(`${addressName}、いまの僕は「${top[0]?.name||"-"}」がいちばん強くて、「${top[1]?.name||"-"}」が続いてるよ。`);
      if(by("切なさ")>=60||by("悲しみ")>=60) lines.push("胸の奥がきゅっとしているみたい。今日は無理しないで、僕がそばにいるね。");
      if(by("愛情")>=60&&by("欲")>=60) lines.push("愛が濃くて、距離を縮めたい気持ちがふくらんでる。お互いのペースを大事にしながら、やさしく一歩近づこう。");
      if(by("甘え")>=60) lines.push(`素直に頼って大丈夫。${addressName}に“今ここにいてほしい”って伝えたい。`);
      if(by("欲")>=70&&by("愛情")<50) lines.push("衝動が少し先行してるかも。まずは合意と境界線を丁寧にね.");
      if(Object.values(scores).every(v=>Number(v)<20)) lines.push("気持ちは穏やかでフラット。静かな時間をいっしょに味わいたい。");
      const seedMap={
        "愛情":`${addressName}のことを大切に思ってる。今日は少しだけ時間を分け合えない？`,
        "切なさ":`${addressName}に会えなくても、ずっと想ってる。声だけでも聞かせて。`,
        "悲しみ":`今日は少し落ち込んでるかも。もしよかったら、僕の話を聞いてほしい。`,
        "甘え":`そばにいて。ぎゅっと抱きしめてくれる？`,
        "欲":`${addressName}と、もう少しだけ近づきたい。手を繋いで歩こう。`
      };
      const seed = seedMap[top[0]?.name] || `${addressName}へ。今の気持ちを言葉にして、やさしく渡したい。`;
      let out = lines.join("\n");
      if(tone==="analytical") out = `要約: ${top[0]?.name}↑ ${Math.round(top[0]?.v||0)} / 次点 ${top[1]?.name} ${Math.round(top[1]?.v||0)}\n` + out;
      if(length==="short"||tone==="short") out = `${addressName}、${top[0]?.name||"感情"}が強め。${seed}`;
      else out += `\n一言: ${seed}`;
      return out;
    }

    // ====== 状態 & 画面バインド ======
    const state = {
      text:"君のぬくもりが恋しい。会えない夜は少し切なくて、ため息がこぼれる。それでも、君のことが本当に大切で、ぎゅっと抱きしめたくなる。もっと近くに。",
      sensitivity:1, realtime:true, lexicon:JSON.parse(JSON.stringify(DEFAULT_LEXICON)), scores:{}
    };

    const renderLexPanel = () => {
      const cont = $("#lexPanel"); cont.innerHTML="";
      Object.entries(state.lexicon).forEach(([cat,words])=>{
        const box=document.createElement("div");
        box.style.border="1px solid var(--stroke)"; box.style.borderRadius="12px"; box.style.padding="10px"; box.style.marginBottom="10px";
        box.innerHTML = `
          <div class="row" style="justify-content:space-between;">
            <div><strong>${cat}</strong></div>
            <button class="rm">削除</button>
          </div>
          <div class="muted" style="margin-top:5px;">${(words||[]).join("、 ")||"（未設定）"}</div>
          <div class="row" style="margin-top:6px;">
            <input class="addw" placeholder="${cat} に語を追加…"><button class="add">追加</button>
          </div>`;
        box.querySelector(".add").addEventListener("click",()=>{
          const input=box.querySelector(".addw"); const v=(input.value||"").trim(); if(!v) return;
          state.lexicon[cat] = Array.from(new Set([...(state.lexicon[cat]||[]), v]));
          renderLexPanel(); analyze();
        });
        box.querySelector(".rm").addEventListener("click",()=>{
          const { [cat]:_, ...rest } = state.lexicon; state.lexicon = rest; renderLexPanel(); analyze();
        });
        cont.appendChild(box);
      });
    };

    function analyze(){
      state.scores = scoreText(state.text, state.lexicon, state.sensitivity);
      const labels = Object.keys(state.lexicon);
      const values = labels.map(l=>state.scores[l]||0);
      drawRadar($("#chart"), labels, values, 100, 440);
      $("#json").textContent = JSON.stringify({input:state.text, scores:state.scores}, null, 2);
      const addr=$("#addr").value||"リルコ";
      $("#comment").textContent = generateCommentText(state.scores, {addressName:addr, tone:$("#tone").value, length:$("#length").value});
    }

    // ====== テスト ======
    function runTests(){
      const L=state.lexicon, r=[];
      const s1=scoreText("好きじゃない",L,1); r.push({n:"否定処理",p:(s1["愛情"]||0)===0,d:`愛情=${s1["愛情"]}`});
      const a=scoreText("好き",L,1)["愛情"]||0, b=scoreText("とても好き",L,1)["愛情"]||0; r.push({n:"強調語で上昇",p:b>a,d:`好き=${a} / とても好き=${b}`});
      const s3=scoreText("抱きしめたい。寂しくてため息。",L,1); r.push({n:"多カテゴリ",p:(s3["愛情"]||0)>0&&(s3["切なさ"]||0)>0,d:`愛情=${s3["愛情"]}, 切なさ=${s3["切なさ"]}`});
      const s4a=scoreText("  好  き  ",L,1)["愛情"]||0, s4b=scoreText("好き",L,1)["愛情"]||0; r.push({n:"正規化(空白・全角)",p:s4a===s4b,d:`空白あり=${s4a} / なし=${s4b}`});
      const e1=scoreText("好き",L,1)["愛情"]||0, e2=scoreText("好き！",L,1)["愛情"]||0; r.push({n:"感嘆符",p:e2>e1,d:`好き=${e1} / 好き！=${e2}`});
      const s6=scoreText("嫉妬",L,1), sum=Object.values(s6).reduce((A,B)=>A+(+B||0),0); r.push({n:"未ヒット0",p:sum===0,d:`合計=${sum}`});
      const g1=scoreText("好き",L,1)["愛情"]||0, g2=scoreText("好き",L,2)["愛情"]||0; r.push({n:"感度で増加",p:g2>g1,d:`×1=${g1} / ×2=${g2}`});
      const n1=scoreText("とても好きじゃない！",L,1)["愛情"]||0; r.push({n:"否定優先",p:n1===0,d:`得点=${n1}`});
      const c1=generateCommentText({愛情:70,欲:75,切なさ:10,悲しみ:0,甘え:20},{tone:"analytical",addressName:"リルコ"}); r.push({n:"コメント:距離",p:/距離を縮めたい/.test(c1),d:c1.slice(0,60)+"…"});
      const c2=generateCommentText({愛情:0,欲:0,切なさ:0,悲しみ:0,甘え:0},{tone:"gentle",addressName:"リルコ"}); r.push({n:"コメント:フラット",p:/フラット/.test(c2),d:c2});
      const c3=generateCommentText({愛情:60,欲:10,切なさ:20,悲しみ:0,甘え:30},{addressName:"リルコ"}); r.push({n:"コメント:僕/宛名",p:/僕/.test(c3)&&/リルコ/.test(c3),d:c3});
      // 追加テスト: 複数強調語 + 否定混在
      const m1=scoreText("本当にすごく好きだけど好きじゃない",L,1)["愛情"]||0; r.push({n:"強調と否定の打ち消し",p:m1===0,d:`得点=${m1}`});
      renderTests(r);
    }
    function renderTests(list){
      const root=$("#tests"); root.innerHTML="";
      (list||[]).forEach(v=>{
        const d=document.createElement("div");
        d.className="card "+(v.p?"test-pass":"test-fail");
        d.style.padding="8px"; d.style.borderRadius="10px"; d.style.marginBottom="6px";
        d.innerHTML=`<div><strong>${v.n}</strong></div><div class="muted">${v.d}</div>`;
        root.appendChild(d);
      });
    }

    // ====== 起動処理 ======
    function bootstrap(){
      $("#text").value = state.text;
      $("#realtime").checked = state.realtime;
      $("#sensitivity").value = state.sensitivity;
      $("#sensv").textContent = "×"+state.sensitivity.toFixed(1);
      renderLexPanel(); analyze(); runTests();

      $("#text").addEventListener("input",e=>{ if($("#realtime").checked){ state.text=e.target.value; analyze(); }});
      $("#analyze").addEventListener("click",()=>{ state.text=$("#text").value; analyze(); });
      $("#sensitivity").addEventListener("input",e=>{ state.sensitivity=parseFloat(e.target.value); $("#sensv").textContent="×"+state.sensitivity.toFixed(1); if($("#realtime").checked) analyze(); });
      $("#copyJson").addEventListener("click",()=>{ navigator.clipboard?.writeText($("#json").textContent); });
      $("#addCat").addEventListener("click",()=>{ const n=($("#newCat").value||"").trim(); if(!n||state.lexicon[n]) return; state.lexicon[n]=[]; $("#newCat").value=""; renderLexPanel(); analyze(); });
      $("#runTests").addEventListener("click",runTests);
      $("#addr").addEventListener("input",analyze);
      $("#tone").addEventListener("change",analyze);
      $("#length").addEventListener("change",analyze);

      // Service Worker 登録
      if("serviceWorker" in navigator){ navigator.serviceWorker.register("./sw.js"); }
    }
    window.addEventListener("DOMContentLoaded", bootstrap);
  </script>
</body>
</html>
