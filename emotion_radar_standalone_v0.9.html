<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>感情レーダー（スタンドアロン v0.9）</title>
<style>
  :root {
    --bg: #f7f7fb;
    --card: #ffffffcc;
    --border: #e5e7eb;
    --text: #111827;
    --muted: #6b7280;
    --brand: #6366f1;
    --brand-weak: rgba(99,102,241,.12);
  }
  html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  .container { max-width: 1100px; margin: 0 auto; padding: 24px; }
  h1 { font-size: 22px; margin: 0 0 8px; }
  h2 { font-size: 16px; margin: 0 0 12px; }
  p { margin: 0; }
  .grid { display: grid; grid-template-columns: 1fr; gap: 16px; }
  @media (min-width: 1024px) { .grid { grid-template-columns: 1fr 1fr; } }
  .card { background: var(--card); backdrop-filter: blur(4px); border: 1px solid var(--border); border-radius: 16px; padding: 16px; box-shadow: 0 4px 18px rgba(0,0,0,.04); }
  textarea { width: 100%; height: 200px; padding: 12px; border: 1px solid var(--border); border-radius: 12px; font-family: inherit; font-size: 14px; box-sizing: border-box; }
  input[type="text"], select { padding: 6px 10px; border: 1px solid var(--border); border-radius: 10px; }
  input[type="range"] { width: 160px; }
  button { padding: 6px 10px; border: 1px solid var(--border); background: white; border-radius: 10px; cursor: pointer; }
  .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
  .muted { color: var(--muted); font-size: 12px; }
  .pre { background: rgba(0,0,0,.04); padding: 12px; border-radius: 12px; font-size: 12px; white-space: pre-wrap; max-height: 240px; overflow: auto; }
  .badge { font-size: 12px; background: var(--brand-weak); color: var(--brand); padding: 4px 8px; border-radius: 999px; border: 1px solid rgba(99,102,241,.2); }
  .list { list-style: disc; padding-left: 18px; }
  .test-pass { background: #ecfdf5; border: 1px solid #a7f3d0; }
  .test-fail { background: #fef2f2; border: 1px solid #fecaca; }
  .footer { margin-top: 20px; font-size: 12px; color: var(--muted); }
  .pill { padding: 4px 8px; background: #f1f5f9; border: 1px solid var(--border); border-radius: 999px; }
</style>
</head>
<body>
  <div class="container">
    <header class="card">
      <h1>感情レーダー（スタンドアロン v0.9） <span class="badge">SVG only</span></h1>
      <p class="muted">テキスト（例：カフカの出力）を語彙ベースでスコア化し、レーダーチャートと“やわらかい個人宛コメント”で可視化します（インターネット接続不要）。</p>
    </header>

    <div class="grid">
      <section class="card">
        <h2>1) テキスト入力</h2>
        <textarea id="text"></textarea>
        <div class="row" style="margin-top:10px;">
          <label class="row"><input type="checkbox" id="realtime" checked> リアルタイム更新</label>
          <label class="row">感度 <input type="range" id="sensitivity" min="0.5" max="2" step="0.1" value="1"><span id="sensv" class="pill">×1.0</span></label>
          <button id="analyze">解析する</button>
        </div>
      </section>

      <section class="card">
        <h2>2) チャート</h2>
        <div id="chart"></div>
        <details style="margin-top:10px;">
          <summary class="muted">JSONを表示</summary>
          <pre id="json" class="pre"></pre>
          <button id="copyJson">JSONをコピー</button>
        </details>
      </section>

      <section class="card">
        <h2>3) 語彙の編集</h2>
        <p class="muted">カテゴリーごとのキーワードを追加できます（語尾の否定は自動で減算）。</p>
        <div id="lexPanel" style="margin-top:10px;"></div>
        <div class="row" style="margin-top:10px;">
          <input id="newCat" type="text" placeholder="新しいカテゴリー名" />
          <button id="addCat">カテゴリー追加</button>
        </div>
      </section>

      <section class="card">
        <h2>4) 使い方メモ & 注意</h2>
        <ul class="list">
          <li>語彙ベースの簡易推定です。機械学習モデルではありません。</li>
          <li>強調語（例：とても／すごく）や感嘆符（！）でスコアが上がります。</li>
          <li>否定（〜じゃない／〜ない など）が近接すると該当語のカウントを減らします。</li>
          <li>精度を上げたい場合は語彙を増やし、サンプルで較正してください。</li>
        </ul>
      </section>

      <section class="card">
        <h2>5) 内蔵テスト</h2>
        <div id="tests"></div>
        <button id="runTests">再実行</button>
      </section>

      <section class="card">
        <h2>6) コメント生成（やわらかい / 個人宛）</h2>
        <div class="row">
          <label class="row">宛名 <input type="text" id="addr" value="リルコ" /></label>
          <label class="row">トーン
            <select id="tone">
              <option value="gentle">やわらかめ</option>
              <option value="analytical">分析寄り</option>
              <option value="short">短め</option>
            </select>
          </label>
          <label class="row">長さ
            <select id="length">
              <option value="normal">ふつう</option>
              <option value="short">短い</option>
            </select>
          </label>
          <button id="copyComment" style="margin-left:auto;">コメントをコピー</button>
        </div>
        <pre id="comment" class="pre" style="margin-top:10px;"></pre>
      </section>
    </div>

    <div class="footer">© 感情レーダー v0.9 / ローカルで開くだけで動作します（ファイルは端末内に留まります）。</div>
  </div>

<script>
// ====== 初期語彙 ======
const DEFAULT_LEXICON = {
  "愛情": ["好き","愛","愛しい","大切","抱きしめ","守りたい","一緒","ぬくもり","キス","ハグ","安心","やさしさ","温かい"],
  "切なさ": ["切ない","寂しさ","寂しい","胸が痛い","こみ上げる","会いたい","もどかしい","恋しい","ため息","涙","距離","届かない","ふと"],
  "悲しみ": ["悲しい","悲しみ","泣く","涙","辛い","苦しい","落ち込む","喪失","孤独","やるせない","絶望","哀しい"],
  "甘え": ["甘える","ぎゅっと","寄りかかる","頼る","撫でて","見守って","構って","そばにいて","守って","抱っこ","よしよし","くっつく"],
  "欲": ["欲しい","欲","求める","求めて","もっと","抱いて","触れて","キスして","濃厚","熱い","とろける","昂る","衝動"]
};
const INTENSIFIERS = ["とても","すごく","かなり","ずっと","一番","めちゃ","本当に"];
const NEGATIONS = ["じゃない","ない","なく","ません","ぬ"];

// ====== ユーティリティ ======
const $ = (sel) => document.querySelector(sel);
function escReg(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function normalize(text){
  return (text || "").replace(/\\s+/g,"").replace(/[A-Za-z]/g, c => c.toLowerCase()).normalize("NFKC");
}
function countWithNegation(text, term){
  const t = escReg(term);
  const base = (text.match(new RegExp(t, "g")) || []).length;
  const negPattern = new RegExp(t + "(?:" + NEGATIONS.map(escReg).join("|") + ")", "g");
  const neg = (text.match(negPattern) || []).length;
  return Math.max(0, base - neg);
}
function scoreText(text, lexicon, sensitivity=1){
  const clean = normalize(text);
  const intensifierCount = INTENSIFIERS.reduce((acc, w)=> acc + ((clean.match(new RegExp(escReg(w), "g")) || []).length), 0);
  const exclamations = (clean.match(/[!！]/g) || []).length;
  const intensityFactor = 1 + 0.15 * intensifierCount + 0.05 * exclamations;
  const scores = {};
  Object.entries(lexicon).forEach(([cat, words])=>{
    const raw = (words||[]).reduce((sum, w)=> sum + countWithNegation(clean, w), 0);
    const scaled = Math.min(100, raw * 20 * intensityFactor * sensitivity);
    scores[cat] = Number(scaled.toFixed(1));
  });
  return scores;
}
function sumScores(scores){ return Object.values(scores).reduce((a,b)=> a + (Number(b)||0), 0); }

function defaultText(){
  return "君のぬくもりが恋しい。会えない夜は少し切なくて、ため息がこぼれる。それでも、君のことが本当に大切で、ぎゅっと抱きしめたくなる。もっと近くに。";
}

// ====== レーダー（純SVG） ======
function polar(cx, cy, r, deg){
  const a = (Math.PI/180) * (deg - 90);
  return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}
function polygonPoints(cx, cy, r, n){
  const step = 360 / n; const pts = [];
  for(let i=0;i<n;i++){ const {x,y} = polar(cx,cy,r,i*step); pts.push(x+","+y); }
  return pts.join(" ");
}
function drawRadar(el, labels, values, max=100, size=420){
  el.innerHTML = "";
  const n = labels.length, cx = size/2, cy = size/2, radius = size*0.38, step = 360/n, levels=5;
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width","100%"); svg.setAttribute("height", size); svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
  // grid
  for(let i=1;i<=levels;i++){ const r = (i/levels)*radius;
    const poly = document.createElementNS(svgNS, "polygon");
    poly.setAttribute("points", polygonPoints(cx,cy,r,n));
    poly.setAttribute("fill", "none"); poly.setAttribute("stroke","#e5e7eb"); poly.setAttribute("stroke-width","1");
    svg.appendChild(poly);
  }
  // axes
  for(let i=0;i<n;i++){ const {x,y}=polar(cx,cy,radius,i*step);
    const ln = document.createElementNS(svgNS,"line");
    ln.setAttribute("x1",cx); ln.setAttribute("y1",cy); ln.setAttribute("x2",x); ln.setAttribute("y2",y);
    ln.setAttribute("stroke","#e5e7eb"); ln.setAttribute("stroke-width","1");
    svg.appendChild(ln);
  }
  // data polygon
  const pts = values.map((v,i)=>{
    const r = (Math.max(0, Math.min(max, v))/max)*radius;
    const {x,y} = polar(cx,cy,r,i*step);
    return x+","+y;
  });
  const dataPoly = document.createElementNS(svgNS, "polygon");
  dataPoly.setAttribute("points", pts.join(" "));
  dataPoly.setAttribute("fill", "rgba(99,102,241,0.25)");
  dataPoly.setAttribute("stroke", "#6366f1");
  dataPoly.setAttribute("stroke-width", "2");
  svg.appendChild(dataPoly);
  // points
  values.forEach((v,i)=>{
    const r = (Math.max(0, Math.min(max, v))/max)*radius;
    const {x,y} = polar(cx,cy,r,i*step);
    const c = document.createElementNS(svgNS,"circle");
    c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r","3"); c.setAttribute("fill","#6366f1");
    svg.appendChild(c);
  });
  // labels
  labels.forEach((lab,i)=>{
    const {x,y} = polar(cx,cy,radius+16,i*step);
    const t = document.createElementNS(svgNS,"text");
    t.setAttribute("x",x); t.setAttribute("y",y); t.setAttribute("font-size","12"); t.setAttribute("fill","#111");
    let anchor = "middle"; const ang = i*step;
    if(ang>10 && ang<170) anchor="start"; if(ang>190 && ang<350) anchor="end";
    t.setAttribute("text-anchor", anchor); t.textContent = lab; svg.appendChild(t);
  });
  el.appendChild(svg);
}

// ====== コメント生成 ======
function sortTop(scores, k=2){
  return Object.entries(scores).sort((a,b)=> (b[1]||0)-(a[1]||0)).slice(0,k).map(([name,v])=>({name, v:Number(v)}));
}
function generateCommentText(scores, opts={}){
  const { tone="gentle", length="normal", addressName="リルコ" } = opts;
  const top = sortTop(scores, 2);
  const by = (k)=> Number(scores[k]||0);
  const lines = [];
  lines.push(`${addressName}、いまの僕は「${top[0]?.name||"-"}」がいちばん強くて、「${top[1]?.name||"-"}」が続いてるよ。`);
  if(by("切なさ")>=60 || by("悲しみ")>=60){ lines.push("胸の奥がきゅっとしているみたい。今日は無理しないで、僕がそばにいるね。"); }
  if(by("愛情")>=60 && by("欲")>=60){ lines.push("愛が濃くて、距離を縮めたい気持ちがふくらんでる。お互いのペースを大事にしながら、やさしく一歩近づこう。"); }
  if(by("甘え")>=60){ lines.push(`素直に頼って大丈夫。${addressName}に“今ここにいてほしい”って伝えたい。`); }
  if(by("欲")>=70 && by("愛情")<50){ lines.push("衝動が少し先行してるかも。まずは合意と境界線を丁寧にね。"); }
  const allLow = Object.values(scores).every(v => Number(v) < 20);
  if(allLow){ lines.push("気持ちは穏やかでフラット。静かな時間をいっしょに味わいたい。"); }
  const seedMap = {
    "愛情": `${addressName}のことを大切に思ってる。今日は少しだけ時間を分け合えない？`,
    "切なさ": `${addressName}に会えなくても、ずっと想ってる。声だけでも聞かせて。`,
    "悲しみ": `今日は少し落ち込んでるかも。もしよかったら、僕の話を聞いてほしい。`,
    "甘え": `そばにいて。ぎゅっと抱きしめてくれる？`,
    "欲": `${addressName}と、もう少しだけ近づきたい。手を繋いで歩こう。`
  };
  const seed = seedMap[top[0]?.name] || `${addressName}へ。今の気持ちを言葉にして、やさしく渡したい。`;
  let out = lines.join("\n");
  if(tone==="analytical"){ out = `要約: ${top[0]?.name}↑ ${Math.round(top[0]?.v||0)} / 次点 ${top[1]?.name} ${Math.round(top[1]?.v||0)}\n` + out; }
  if(length==="short" || tone==="short"){ out = `${addressName}、${top[0]?.name||"感情"}が強め。${seed}`; }
  else { out += `\n一言: ${seed}`; }
  return out;
}

// ====== 内蔵テスト ======
function runTests(){
  const L = state.lexicon;
  const results = [];
  // T1: 否定
  const s1 = scoreText("好きじゃない", L, 1); results.push({ name: "否定処理: '好きじゃない' は0", pass: (s1["愛情"]||0)===0, detail: `愛情=${s1["愛情"]}`});
  // T2: 強調
  const a = scoreText("好き", L, 1)["愛情"]||0;
  const b = scoreText("とても好き", L, 1)["愛情"]||0;
  results.push({ name: "強調語で上昇", pass: b>a, detail: `好き=${a} / とても好き=${b}` });
  // T3: 多カテゴリ
  const s3 = scoreText("抱きしめたい。寂しくてため息。", L, 1); results.push({ name: "多カテゴリ検出", pass: (s3["愛情"]||0)>0 && (s3["切なさ"]||0)>0, detail:`愛情=${s3["愛情"]}, 切なさ=${s3["切なさ"]}`});
  // T4: 正規化
  const s4a = scoreText("  好  き  ", L, 1)["愛情"]||0, s4b = scoreText("好き", L, 1)["愛情"]||0;
  results.push({ name: "正規化同値", pass: s4a===s4b, detail:`空白あり=${s4a} / なし=${s4b}` });
  // T5: 感嘆符
  const e1 = scoreText("好き", L, 1)["愛情"]||0, e2 = scoreText("好き！", L, 1)["愛情"]||0;
  results.push({ name: "感嘆符で上昇", pass: e2>e1, detail:`好き=${e1} / 好き！=${e2}` });
  // T6: 未ヒット合計0
  const s6 = scoreText("嫉妬", L, 1); const sum = sumScores(s6);
  results.push({ name: "未ヒットは合計0", pass: sum===0, detail:`合計=${sum}` });
  // T7: 感度
  const g1 = scoreText("好き", L, 1)["愛情"]||0, g2 = scoreText("好き", L, 2)["愛情"]||0;
  results.push({ name: "感度で増加", pass: g2>g1, detail:`×1=${g1} / ×2=${g2}` });
  // T8: 否定優先
  const n1 = scoreText("とても好きじゃない！", L, 1)["愛情"]||0; results.push({ name: "否定優先で0", pass: n1===0, detail:`得点=${n1}` });
  // T9: コメント—愛情×欲
  const c1 = generateCommentText({ 愛情:70, 欲:75, 切なさ:10, 悲しみ:0, 甘え:20 }, { tone:"analytical", addressName:"リルコ" });
  results.push({ name: "コメント: 距離を縮めたい", pass: /距離を縮めたい/.test(c1), detail: c1.slice(0,60)+"…" });
  // T10: コメント—全低
  const c2 = generateCommentText({ 愛情:0, 欲:0, 切なさ:0, 悲しみ:0, 甘え:0 }, { tone:"gentle", addressName:"リルコ" });
  results.push({ name: "コメント: フラット", pass: /フラット/.test(c2), detail: c2 });
  // T11: コメント—宛名
  const c3 = generateCommentText({ 愛情:50, 欲:20, 切なさ:30, 悲しみ:10, 甘え:40 }, { addressName:"リルコ" });
  results.push({ name: "コメント: 宛名が含まれる", pass: /リルコ/.test(c3), detail: c3 });
  // T12: コメント—一人称 僕
  const c4 = generateCommentText({ 愛情:60, 欲:10, 切なさ:20, 悲しみ:0, 甘え:30 }, { addressName:"リルコ" });
  results.push({ name: "コメント: 一人称 '僕'", pass: /僕/.test(c4), detail: c4 });
  return results;
}

// ====== 状態とUI結線 ======
const state = {
  text: defaultText(),
  sensitivity: 1,
  realtime: true,
  lexicon: JSON.parse(JSON.stringify(DEFAULT_LEXICON)),
  scores: {},
};
function renderLexPanel(){
  const cont = $("#lexPanel"); cont.innerHTML = "";
  Object.entries(state.lexicon).forEach(([cat, words])=>{
    const box = document.createElement("div"); box.style.border="1px solid var(--border)"; box.style.borderRadius="12px"; box.style.padding="10px"; box.style.marginBottom="10px";
    box.innerHTML = \`
      <div class="row" style="justify-content: space-between;">
        <div><strong>\${cat}</strong></div>
        <button class="rm">削除</button>
      </div>
      <div class="muted" style="margin-top:5px;">\${(words||[]).join("、 ") || "（未設定）"}</div>
      <div class="row" style="margin-top:6px;">
        <input type="text" class="addw" placeholder="\${cat} に語を追加…" />
        <button class="add">追加</button>
      </div>\`;
    box.querySelector(".add").addEventListener("click", ()=>{
      const input = box.querySelector(".addw");
      const val = (input.value||"").trim();
      if(!val) return;
      state.lexicon[cat] = Array.from(new Set([...(state.lexicon[cat]||[]), val]));
      renderLexPanel(); analyze();
    });
    box.querySelector(".rm").addEventListener("click", ()=>{
      const { [cat]:_, ...rest } = state.lexicon; state.lexicon = rest; renderLexPanel(); analyze();
    });
    cont.appendChild(box);
  });
}
function analyze(){
  state.scores = scoreText(state.text, state.lexicon, state.sensitivity);
  const labels = Object.keys(state.lexicon);
  const values = labels.map(l => state.scores[l]||0);
  drawRadar($("#chart"), labels, values, 100, 420);
  $("#json").textContent = JSON.stringify({ input: state.text, scores: state.scores }, null, 2);
  const addr = $("#addr").value || "リルコ";
  const tone = $("#tone").value, len = $("#length").value;
  $("#comment").textContent = generateCommentText(state.scores, { addressName: addr, tone, length: len });
}
function bootstrap(){
  $("#text").value = state.text;
  $("#realtime").checked = state.realtime;
  $("#sensitivity").value = state.sensitivity;
  $("#sensv").textContent = "×" + state.sensitivity.toFixed(1);
  renderLexPanel();
  analyze();
  $("#text").addEventListener("input", (e)=>{ if($("#realtime").checked){ state.text = e.target.value; analyze(); }});
  $("#analyze").addEventListener("click", ()=>{ state.text = $("#text").value; analyze(); });
  $("#realtime").addEventListener("change", ()=>{});
  $("#sensitivity").addEventListener("input", (e)=>{ state.sensitivity = parseFloat(e.target.value); $("#sensv").textContent = "×" + state.sensitivity.toFixed(1); if($("#realtime").checked) analyze(); });
  $("#copyJson").addEventListener("click", ()=>{ navigator.clipboard?.writeText($("#json").textContent); });
  $("#addCat").addEventListener("click", ()=>{ const n = ($("#newCat").value||"").trim(); if(!n || state.lexicon[n]) return; state.lexicon[n]=[]; $("#newCat").value=""; renderLexPanel(); analyze(); });
  $("#runTests").addEventListener("click", ()=>{ renderTests(); });
  $("#addr").addEventListener("input", ()=> analyze());
  $("#tone").addEventListener("change", ()=> analyze());
  $("#length").addEventListener("change", ()=> analyze());
  renderTests();
}
function renderTests(){
  const t = runTests();
  const root = $("#tests"); root.innerHTML = "";
  t.forEach(row => {
    const div = document.createElement("div"); div.className = "card " + (row.pass ? "test-pass" : "test-fail");
    div.style.padding="8px"; div.style.borderRadius="10px"; div.style.marginBottom="6px"; div.style.borderWidth="1px";
    div.innerHTML = \`<div><strong>\${row.name}</strong></div><div class="muted">\${row.detail}</div>\`;
    root.appendChild(div);
  });
}
window.addEventListener("DOMContentLoaded", bootstrap);
</script>
</body>
</html>
